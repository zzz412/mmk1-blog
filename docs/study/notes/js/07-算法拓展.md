# 算法

## 什么是算法

> 算法(Algorithm）是指**解题方案的准确而完整的描述**，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，**能够对一定规范的输入，在有限时间内获得所要求的输出。**
>
> **简单说**
>
> 算法就是把一个问题,拆解为**计算机能够一步步执行的步骤.**
>
> 计算机的流程控制语句:顺序执行、选择语句、循环语句

**优秀算法的要求**

> 正确性
>
> 健壮性
>
> 可读性

## 伪代码

**计算1+2+3+4+.....+99+100**

> **定义变量sum** 
>
> **从1到100遍历数字 , 用 i 表示 把每个数字i加到sum中打印显示sum**

```js
for(let i = 1;i <= 100; i++){
        document.write(i + "<br>");   // 1 2 3 100
    }
```

## 算法如何培养?

> 多敲、多练、多总结
>
> 经典的业务需求场景要熟记心间

## 累加器和累乘器

### 累加器题目

[![wHy0YR.png](https://s1.ax1x.com/2020/09/21/wHy0YR.png)](https://imgchr.com/i/wHy0YR)

```html
<script>
    // 由用户输入数字n 计算3/2 + 4/3 + 5/4 + ... +(n+1)/n的结果

    //用户输入数字n
    let n = Number(prompt("请输入数字n"));

    // 累加器
    let sum = 0;

    // 遍历分母就可以了 , 因为分母就是分子 + 1
    for (let i = 2; i <= n; i++) {
    	sum += (i + 1) / i;
    }

    alert(sum.toFixed(2));
    
    //输入5    === >  5.28   ====> 3/2 + 4/3 + 5/4 + 6/5
</script>
```

### 累乘器题目

> **由用户输入数字n，请计算n的阶乘**

```css
6的阶乘   ===>   6 * 5 * 4 * 3 * 2 * 1
```

```js
// 计算阶乘

//用户输入数字n
let n = Number(prompt("请输入一个数字"));

//累乘器  一定注意  累乘器要从1开始 , 因为如果从0开始,0乘以任何数字都是0
let result = 1;


for(let i = n; i >= 1; i--){
	result *= i;
}

// for(let i = 1; i <= n; i++){
// 	result *= i;
// }	

//显示结果
alert(result);
```

### 同时用到累加器和累乘器

> **[某大厂面试题]圆周率π可以由下面的莱布尼茨级数公式计算出来，请由用户输入参数n，计算圆周率π**

[![wHHhNt.png](https://s1.ax1x.com/2020/09/21/wHHhNt.png)](https://imgchr.com/i/wHHhNt)

```html
 <script>

      // 用莱布尼茨数估算圆周率

      //   π = 2 * ( 1 + 1/3 + (1*2)/(3*5) + (1*2*3)/(3*5*7) + (1*2*3*4)/(3*5*7*9) + (1 * ....n)/(3*5*/2n+1)   ) 
      
      let n = Number(prompt("请输入一个数字n"));

      // 累加器  就是最后的答案
      let sum = 0;

      // 累乘器   就是最后的答案    
      let item = 1;  

      for (let i = 1; i <= n; i++) {
        
        // 要先制作这一项 , 每一项怎么制作? 要使用累乘器   item是小车厢
        item *= i / (2 * i + 1);
          
        console.log(item);
      }
    
    </script>
```

```html
<script>

      // 用莱布尼茨数估算圆周率

 // π = 2 * ( 1 + 1/3 + (1*2)/(3*5) + (1*2*3)/(3*5*7) + (1*2*3*4)/(3*5*7*9) + (1 * ....n)/(3*5*/2n+1)   ) 
      
      let n = Number(prompt("请输入一个数字n"));

      // 累加器  就是最后的答案
      let sum = 0;

      // 累乘器   就是最后的答案
      
      let item = 1;  

      for (let i = 1; i <= n; i++) {
        
        // 要先制作这一项 , 这一项怎么制作? 要使用累乘器
        item *= i / (2 * i + 1);


        // console.log(item);

        // 把车厢往累加器中累加
        sum += item;
      }

      // 计算结果
     alert(2 * (1 + sum));
    
    </script>
```

## 穷举法

### 穷举法是什么

> 计算机最突出的能力就是计算，它没有归纳总结、逻辑推理的能力。所以人们使用计算机解决问题的时候，要“扬长避短”—**充分发挥计算机的计算优势，而不要让它进行逻辑推理。**穷举法就是这样的一种算法思想。
>
> 
>
> 穷举法，顾名思义，是指根据题目的条件确定答案的大致范围，并**在此范围内对所有可能的情况逐一验证**，直到全部情况验证完毕。若某个情况符合题目的条件，则为本问题的一个解;若全部情况验证后都不符合题目的条件，则本题无解。

### 题目1

> 编程寻找100以内的既能被3整除，也能被5整除的数字
>
> **既能被3整除，也能被5整除的数字  ==> 人脑  ===>  15的倍数**

```js
// 寻找100 以内 既能被3整除  也能被5整除的数字

// 穷举法,从1开始试验

for(let i = 1; i <= 100; i++){
    if( i % 3 == 0 && i % 5 == 0){
        console.log(i);  
    }
}
```

### 题目2

> 用户输入一个数字，在控制台显示这个数字的全部约数
>
> **48的约数  ==>   1、2、3、4、6、8、12、16、24、48**

```js
let n = Number(prompt("请输入数字"));

//   穷举法;

for (let i = 1; i <= n; i++) {
    if (n % i == 0) {
        console.log(i);
    }
}
```

### 题目3

> **寻找全部的水仙花数。水仙花数是这样的一个3位数:它的每个数位的数字的立方和等于它本身。**

```js
// 寻找水仙花数
for(let i = 100; i < 1000; i++){
    // 水仙花数要拆数位

    // a b c 分别表示百位 , 十位 ,个位
    let i_str = i.toString();

    let a  = i_str.charAt(0);
    let b  = i_str.charAt(1);
    let c  = i_str.charAt(2);

    // console.log(a , b, c);

    // 数学运算会隐式转换
    if(Math.pow(a , 3) + Math.pow(b , 3) + Math.pow(c , 3) == i) {
    	console.log(i);//153 370 371 407
    }
}
```

## 综合算法题

### 循环嵌套

```js
for(let i = 0; i < 3; i++){
    for(let j = 0; j < 3; j++){
        console.log(i , j);
    }
}
```

### 题目1

> 请寻找1~100的所有质数
>
> **质数:只能够被1和它本身整除的数字，最小的质数是2**
>
> **比如:2、3、5、7、11、13，17、19、23、29 、31、37....**

```js
// 请寻找 1 - 100的所有质数

      // 穷举法
outer: for (let i = 2; i <= 100; i++) {
        // 内层循环开始从2开始到小于这个数字的每个数字都尝试 模 i,如果能够整除,说明他不是质数,就可以筛选下一个数字
        for (let j = 2; j < i; j++) {
          if (i % j == 0) {
            // 说明数字i不是质数 因为他找到了除1和它自身之外的约数了,测试下一个数字
            //continue表示放弃这个数字,开始迭代下个数字,continue它负责的是他所在最内层的for循环
            //要给外层for循环加上label . 然后在continue后面加上这个label
            // 这样就表示立即开始迭代外层for循环的下一个数字了,而不是内层for循环
            continue outer;
          }
        }

        // 能够遇见这条语句的数字i , 一定是质数 , 否则就被continue略过了
        console.log(i);
      }
```

### 题目2

> **有雉兔同笼，上有三十五头，下有九十四足，问雉兔各几何**
>
> 我们可以设 鸡 为 x  设置兔子为 y
>
> **列出二元一次的方程式**
>
> - **a + b = 35**
> - **2a + 4b = 94**

**方法一** 

```js
//  鸡兔同笼的问题
// 假设小鸡有 a 只  兔子有 b 只
for (let a = 0; a <= 35; a++) {
    for (let b = 0; b <= 35; b++) {
        if (a + b == 35 && 2 * a + 4 * b == 94) {
            console.log("小鸡有" + a + "只", "兔子有" + b + "只");
        }
    }
}
```

**方法二**

```js
// 假设小鸡有 a 只  那么兔子有 35 - a只
for (let a = 0; a <= 35; a++) {
    let b = 35 - a;
    if (2 * a + 4 * b == 94) {
        console.log("小鸡有" + a + "只", "兔子有" + b + "只");
    }
}
```

### 题目3

> **假如有一张厚度为1mm的纸 , 对折多少次可以达到珠穆朗玛峰的高度  8848m**

```html
 <script>
      // 1m = 10dm = 100cm = 1000mm

      let a = 1;

      let b = 8848000;

      let i = 0;
      while (true) {
        i++;
        a *= 2;
        console.log("第" + i + "次对折", "厚度为" + a / 100 + "米");

        if (a > b) {
          break;
        }
      }

      console.log(i);//24
    </script>
```

### 题目4

> **一元纸币 . 二元纸币 , 五元纸币**
>
> **要去 : 每种面值最低一张  .  最多不限制**
>
> **问:有多少种排列能够凑齐 100 元**

```html
 <script>
      //   i ===   1元   最多93张
      //   j ===   2元   最多47张
      //   m ===   5元   最多19张

      let count = 0;

      for(let i = 1; i <= 93; i++){
        for(let j = 1; j <= 47; j++){
          for(let m = 1; m <= 19; m++){
            if(1*i + 2*j + 5*m === 100){
                count++;
                console.log("第"+ count + "种情况" + "一元" + i + "张" + "二元" + j + "张" + "三元" + m + "张");
            }
          }
        }
      }
</script>
```

